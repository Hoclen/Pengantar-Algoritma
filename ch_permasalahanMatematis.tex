\chapter{Permasalahan Matematis}\label{ch:modul2}


\section{Basis Numerik}
Pada umumnya, basis desimal merupakan basis yang paling sering digunakan dalam kehidupan sehari-hari. Akan tetapi sebagai seorang programmer, pemahaman akan basis lain khususnya heksadesimal dan biner sangat penting. Basis-basis yang sering dipakai dalam pemrograman adalah sebagai berikut.
\begin{enumerate}
	\item Biner --- Basis-2 yang terdiri dari angka 1 dan 0. Ini merupakan basis yang alami yang digunakan di dalam pemrosesan komputer (semua perhitungan komputer harus diganti dari desimal menjadi biner baru diproses oleh prosessor). \\
	Contoh: $101_2 = 5_{10}$.
	\item Oktal --- Basis-8 merupakan basis yang sering digunakan untuk menyingkat pembacaan biner supaya menjadi gampang. Caranya adalah merubah setiap 3 angka menjadi satu bilangan oktal dari kanan.\\
	Contoh: $1101_2 = 15_8\ (001\rightarrow1, 101\rightarrow5)$, $110111011_2 = 673_8$.
	\item Decimal --- Basis-10 merupakan basis yang kita gunakan setiap hari.
	\item Heksadesimal --- Basis-16 merupakan basis yang lebih gampang lagi dalam merepresentasikan bilangan biner daripada basis-8. Heksadesimal merupakan basis yang paling sering digunakan selain dari desimal dalam dunia komputasi. Cara konversi dari biner ke heksadesimal adalah dengan merubah setiap 4 angka menjadi satu bilangan heksa (0-9,A-F)\\
	Contoh: $110111011_2 = 1BB_{16}\ (0001\rightarrow1, 1011\rightarrow B, 1011\rightarrow B)$
	\item Alfanumerik --- Alfanumerik merupakan basis-36 dan merupakan basis tertinggi yang bisa direpresentasikan oleh angka 0 - 9 dan huruf A - Z.  
\end{enumerate}

Untuk mengkonversi dari satu basis ke basis lain diperlukan sebuah algoritma yang bernama Algoritma \textit{Right-to-Left}. 

\begin{algorithm}[H]
	\caption{RIGHT-TO-LEFT($decimal$)}
	\label{algo:rightToLeft}
	\begin{algorithmic}[1]
		\STATE $pos = 1$
		\WHILE{$decimal>0$}
			\STATE $A[pos] = decimal\ \%\ 8$ \COMMENT{Ganti angka 8 menjadi basis yang anda inginkan} 
			\STATE $decimal = decimal\ /\ 8$
			\STATE $pos = pos\ +\ 1$
		\ENDWHILE
		\FOR{$i=1$ \TO $(pos\ -\ 1)/2$}
			\STATE $temp = A[i]$
			\STATE $A[i] = A[pos-i]$
			\STATE $A[pos-i] = temp$
		\ENDFOR
	\end{algorithmic}
\end{algorithm}




\section{Faktorial}
Faktorial didefinisikan sebagai $Fac(n) =  n * Fac(n-1)$, dengan ketentuan $Fac(1) = 1$. 
\begin{contoh}
	\textbf{Perhitungan Faktorial}
	\begin{align*}
		&Fac(1) = 1\\
		&Fac(0) = 1\\
		&Fac(3) = 3 * Fac(2)\\
		&Fac(3) = 3 * 2 * Fac(1)\\
		&Fac(3) = 3 * 2 * 1\\
		&Fac(3) = 6
	\end{align*}
\end{contoh}

\FloatBarrier
Ada dua algoritma yang tersedia untuk mengkalkulasi sebuah faktorial dari bilangan $n$: rekursif dan iteratif.

\begin{algorithm}[H]
	\caption{FAKTORIAL-ITERATIF($n$)}
	\begin{algorithmic}[1]
		\STATE $result = 1$
		\FOR{$i=1$ \TO $n$}
			\STATE $result = result * i$
		\ENDFOR
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
	\caption{FAKTORIAL-REKURSIF($n$)}
	\begin{algorithmic}[1]
		\IF{$n == 1$}
			\RETURN 1
		\ELSE
			\RETURN FAKTORIAL-REKURSIF($n-1$) * $n$  
		\ENDIF
	\end{algorithmic}
\end{algorithm}

\FloatBarrier




\section{Fibonacci}
Fibonacci didefinisikan sebagai $Fibo(n) = Fibo(n-2) + Fibo(n-1)$, dengan ketentuan $Fibo(1) = 1$ dan $Fibo(0) = 0$. 
\begin{contoh}
	\textbf{Perhitungan Fibonacci}\\
	\begin{align*}
		&Fibo(1) = 1\\
		&Fibo(0) = 0\\
		&Fibo(3) = Fibo(2) + Fibo(1)\\
		&Fibo(3) = Fibo(1) + Fibo(0) + 1 \\
		&Fibo(3) = 1 + 0 + 1 \\
		&Fibo(3) = 2 \\
	\end{align*}
\end{contoh}

\begin{algorithm}[H]
	\caption{FIBONACCI-REKURSIF($n$)}
	\label{algo:fiboRekursif}
	\begin{algorithmic}[1]
		\IF{$n == 1$} 
			\RETURN 1
		\ELSIF{$n == 0$}
			\RETURN 0
		\ELSE
			\RETURN FIBONACCI-REKURSIF($n-1$) + FIBONACCI-REKURSIF($n-2$)
		\ENDIF
	\end{algorithmic}
\end{algorithm}




\section{Faktor Pembagi Besar (FPB)/ \textit{Greatest Common Divisor} (\textit{GCD}) }
Algoritma GCD digunakan untuk mencari bilangan pembagi terbesar diantara dua buah bilangan. 
\begin{contoh}
	\textbf{GCD}\\
		$GCD(15,18) = 3$ karena 3 merupakan bilangan pembagi terbesar dari bilangan 15 dan 18\\
		$GCD(21,56) = 7$
\end{contoh}

Algoritma untuk menghitung GCD dari Euclid adalah sebagai berikut.
\begin{algorithm}[H]
	\caption{EUCLID-GCD($a$,$b$)}
	\begin{algorithmic}[1]
		\WHILE{$b>0$}
			\STATE $a=a\ \%\ b$
			\STATE $a=a$\ XOR\ $b$
			\STATE $b=b$\ XOR\ $a$
			\STATE $a=a$\ XOR\ $b$
		\ENDWHILE
		\RETURN $a$
	\end{algorithmic}
\end{algorithm}




\section{Matriks}
Sebuah matriks adalah serangkaian bilangan yang disusun dalam bentuk persegi panjang. 
\begin{contoh}
\textbf{Matriks}\\
	Matriks $3\times4$: 
	\begin{displaymath}
		\left(
		\begin{array}{cccc}
			3 & 4 & 8 & 5 \\
			3 & 2 & 9 & 1 \\
			7 & 0 & 2 & 4 
		\end{array}
		\right)
	\end{displaymath}
	Matriks $2\times3$:
	\begin{displaymath}
		\left(
		\begin{array}{ccc}
			5 & 2 & 9 \\
			1 & 0 & 2 
		\end{array}
		\right)
	\end{displaymath}
\end{contoh} 
Vektor adalah sebuah matriks yang terdiri atas satu kolom saja.
\begin{contoh}
	\textbf{Vektor}\\
	x =
	\begin{math}
		\left(
		\begin{array}{c}
			3 \\
			2 \\
			7 
		\end{array}
		\right)
	\end{math}
\end{contoh}

Untuk melakukan perkalian antara dua matriks bisa dilakukan dengan menggunakan algoritma berikut.
\begin{algorithm}[H]
	\caption{MATRIX-MULTIPLY(A,B)}
	\label{algo:matrixMultiply}
	\begin{algorithmic}[1]
		\IF{$A.columns \neq B.rows$}
			\STATE \textbf{error} ``incompatible dimensions''
		\ELSE
			\STATE let $C$ be a new $A.rows\times{}B.columns$ matrix
			\FOR{$i=1$ \TO $A.rows$}
				\FOR{$j=1$ \TO $B.columns$}
					\STATE $c_{ij}=0$
					\FOR{$k=1$ \TO $A.columns$}
						\STATE $c_{ij} = c_{ij} + a_{ik} \cdot b_{kj}$
					\ENDFOR
				\ENDFOR
			\ENDFOR
		\ENDIF
	\end{algorithmic}
\end{algorithm}

\FloatBarrier
\begin{konsep}
Buatkan flowchart dari:
\begin{enumerate}
	\item Algoritma \ref{algo:rightToLeft}\\
	\item Algoritma \ref{algo:matrixMultiply}\\
\end{enumerate}
\end{konsep}

