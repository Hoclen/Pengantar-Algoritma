\chapter{Pengurutan}

\section{Kenapa belajar pengurutan?}
Manfaat mempelajari pengurutan dalam algoritma adalah sebagai berikut.
\begin{enumerate}
	\item Sering kali sebuah aplikasi memerlukan pengurutan, misalnya: aplikasi perbankan perlu mengurutkan data nasabah, aplikasi penjualan perlu mengurutkan catatan penjualan dan sebagainya.
	\item Banyak algoritma menggunakan pengurutan sebagai bagian atau fungsi dari algoritma tersebut. Sebagai contohnya, sebuah aplikasi pengolahan grafis tiga dimensi perlu melakukan pengurutan untuk menampilkan obyek secara betul dari atas sampai bawah (kedalaman).
	\item Dari algoritma pengurutan kita bisa mendapatkan banyak sekali teknik-teknik yang bermanfaat, bahkan banyak dari algoritma pengurutan yang sebenarnya sudah dikembangkan selama bertahun-tahun dan mengimplementasikan banyak teknik-teknik berguna yang bisa kita pelajari untuk digunakan di hal lain.
	\item Kita bisa menggunakan algoritma pengurutan sebagai salah satu tempat untuk mempelajari kompleksitas algoritma.
	\item Banyak bidang-bidang ilmu lain seperti misalnya basis data yang memerlukan algoritma pengurutan.
\end{enumerate}

\section{\textit{Bubble Sort}}
Algoritma \textit{Bubble Sort} merupakan algoritma pengurutan sederhana yang bekerja dengan cara membandingkan setiap elemen dari \textit{Array} dan menukarkan elemen-elemen tersebut. Algoritma \textit{Bubble Sort} bisa dilihat di Algoritma \ref{lst:Bubble}.

\begin{listprog}{BubbleSort.py}
	\label{lst:Bubble}
	\begin{lstlisting}[language=Python]
		data = [5,3,1,8,9,7]		
		for i in range(len(data)-1): 
				for j in range(i+1, len(data)):
						if(data[j]<data[i]):
								print(data)
								temp = data[i]
								data[i] = data[j]
								data[j] = temp

		print(data)
	\end{lstlisting}
\end{listprog}



Simulasi dari Algoritma \ref{lst:Bubble} adalah sebagai berikut.
\begin{verbatim}
[4, 1, 3, 5, 6, 7, 2]

Loop:  1
A[ 0 ]( 4 )>= A[ 1 ]( 1 )= True
Tukar 4 dengan 1
[1, 4, 3, 5, 6, 7, 2]
A[ 0 ]( 1 )>= A[ 2 ]( 3 )= False
[1, 4, 3, 5, 6, 7, 2]
A[ 0 ]( 1 )>= A[ 3 ]( 5 )= False
[1, 4, 3, 5, 6, 7, 2]
A[ 0 ]( 1 )>= A[ 4 ]( 6 )= False
[1, 4, 3, 5, 6, 7, 2]
A[ 0 ]( 1 )>= A[ 5 ]( 7 )= False
[1, 4, 3, 5, 6, 7, 2]
A[ 0 ]( 1 )>= A[ 6 ]( 2 )= False
[1, 4, 3, 5, 6, 7, 2]

Loop:  2
A[ 1 ]( 4 )>= A[ 2 ]( 3 )= True
Tukar 4 dengan 3
[1, 3, 4, 5, 6, 7, 2]
A[ 1 ]( 3 )>= A[ 3 ]( 5 )= False
[1, 3, 4, 5, 6, 7, 2]
A[ 1 ]( 3 )>= A[ 4 ]( 6 )= False
[1, 3, 4, 5, 6, 7, 2]
A[ 1 ]( 3 )>= A[ 5 ]( 7 )= False
[1, 3, 4, 5, 6, 7, 2]
A[ 1 ]( 3 )>= A[ 6 ]( 2 )= True
Tukar 3 dengan 2
[1, 2, 4, 5, 6, 7, 3]

Loop:  3
A[ 2 ]( 4 )>= A[ 3 ]( 5 )= False
[1, 2, 4, 5, 6, 7, 3]
A[ 2 ]( 4 )>= A[ 4 ]( 6 )= False
[1, 2, 4, 5, 6, 7, 3]
A[ 2 ]( 4 )>= A[ 5 ]( 7 )= False
[1, 2, 4, 5, 6, 7, 3]
A[ 2 ]( 4 )>= A[ 6 ]( 3 )= True
Tukar 4 dengan 3
[1, 2, 3, 5, 6, 7, 4]

Loop:  4
A[ 3 ]( 5 )>= A[ 4 ]( 6 )= False
[1, 2, 3, 5, 6, 7, 4]
A[ 3 ]( 5 )>= A[ 5 ]( 7 )= False
[1, 2, 3, 5, 6, 7, 4]
A[ 3 ]( 5 )>= A[ 6 ]( 4 )= True
Tukar 5 dengan 4
[1, 2, 3, 4, 6, 7, 5]

Loop:  5
A[ 4 ]( 6 )>= A[ 5 ]( 7 )= False
[1, 2, 3, 4, 6, 7, 5]
A[ 4 ]( 6 )>= A[ 6 ]( 5 )= True
Tukar 6 dengan 5
[1, 2, 3, 4, 5, 7, 6]

Loop:  6
A[ 5 ]( 7 )>= A[ 6 ]( 6 )= True
Tukar 7 dengan 6
[1, 2, 3, 4, 5, 6, 7]
\end{verbatim}



\section{\textit{Selection Sort}}
Perhatikan pada \textit{Bubble Sort}, pada langkah pengurutannya, proses penukaran elemen (\textit{Swapping}) terjadi sesaat setelah proses perbandingan memenuhi kondisi, padahal belum tentu elemen yang ditukarkan tersebut merupakan elemen final yang akan menempati posisi tersebut. \\
Bagaimana jika dilakukan terlebih dahulu penyimpanan posisi dari elemen yang ditukarkan sebelum dilakukan penukaran elemen. Jika sudah ada kepastian elemen mana yang memenuhi untuk dipertukarkan barulah dilakukan penukaran elemen.\\
Perbaikan ini membawa kita pada teknik pengurutan berikutnya disebut dengan \textit{Selection Sort} yang dapat dilihat pada algoritma \ref{lst:Selection} : 

\begin{listprog}{Selection Sort.py}
	\label{lst:Selection}
	\begin{lstlisting}[language=Python]
		data = [5,3,1,8,9,7]

		for i in range(len(data)-1):
				swapPos = i
				for j in range(i+1, len(data)):
						if(data[j]<data[swapPos]):
								swapPos = j

				if(i != swapPos):
						temp = data[i]
						data[i] = data[swapPos]
						data[swapPos] = temp
				
		print(data)
	\end{lstlisting}
\end{listprog}


Secara proses, simulasi algoritma \textit{Selection Sort} hampir sama dengan \textit{Bubble Sort}, tanpa pertukaran yang terjadi setiap waktu diganti menjadi pertukaran isi dari posisi yang akan dipertukarkan yang diikuti pertukaran diakhir dari perulangan dalam. 

\section{\textit{Insertion Sort}}
Algoritma \textit{Insertion Sort}\sidenote{\textit{Insertion Sort} mengurutkan \textbf{di tempat}: pengurutan terjadi di dalam \textit{array}} merupakan algoritma yang efisien untuk mengurutkan bilangan dalam jumlah yang kecil. Analogi \textit{Insertion Sort} mirip dengan cara seseorang mensortir kartu di tangannya dimana bisa dilihat di Gambar \ref{fig:InsertionSort}.

\begin{figure}%
\includegraphics[scale=0.5]{fig/insertionSort.eps}%
\caption{Menyortir kartu di tangan}%
\label{fig:InsertionSort}%
\end{figure}


Algoritma \textit{Insertion Sort} bisa dilihat di Algoritma \ref{lst:insertion}. 
\begin{listprog}{Insertion Sort.py}
	\label{lst:insertion}
	\begin{lstlisting}[language=Python]
		data = [5,3,1,8,9,7]


		for i in range(1, len(data)):
				temp = data[i]
				j = i - 1
				while(j>=0 and temp<data[j]):
						data[j+1] = data[j]
						j-= 1

				data[j+1] = temp

		print(data)

	\end{lstlisting}
\end{listprog}

\FloatBarrier
Cara kerja Algoritma \ref{lst:insertion} seperti illustrasi dibawah ini.
\begin{figure*}[htbp]%
\includegraphics[scale=0.8]{fig/InsertionSortMethod}%
\caption{Cara kerja \textit{Insertion Sort}}%
\label{fig:caraKerjaInsertion}%
\end{figure*}
\FloatBarrier

Simulasi dari algoritma \textit{Insertion Sort} untuk \textit{array} A yang berisikan \{7,3,4,2,1\} adalah sebagai berikut.
\begin{verbatim}
Loop 1 , Key = 3 > [7, 3, 4, 2, 1] => [3, 7, 4, 2, 1]
Loop 2 , Key = 4 > [3, 7, 4, 2, 1] => [3, 4, 7, 2, 1]
Loop 3 , Key = 2 > [3, 4, 7, 2, 1] => [2, 3, 4, 7, 1]
Loop 4 , Key = 1 > [2, 3, 4, 7, 1] => [1, 2, 3, 4, 7]
\end{verbatim}



\pagebreak
\section{Latihan}
\begin{pemrograman}
Buatkan program python dari Algoritma \ref{lst:insertion}.
\end{pemrograman}

\begin{pemrograman}
\label{lat:cryptanalysis}
\textbf{Permasalahan Cryptanalysis}\\
\textit{Cryptanalysis} merupakan sebuah proses untuk memecahkan tulisan yang bersifat kriptografi. Proses tersebut melibatkan beberapa analisis statistika dari teks yang akan dipecahkan. Tugas anda adalah menuliskan sebuah program untuk melakukan analisis sederhana dari sebuah kalimat.\\
\textbf{Masukan}\\
Sebuah kalimat yang terdiri dari huruf A-Z, 0-9, spasi dan tanda baca lainnya.\\
\textbf{Keluaran}\\
Setiap baris terdiri dari bilangan A-Z dalam huruf kapital yang diikuti satu buah spasi dan bilangan integer positif yang menandakan jumlah huruf tersebut dalam kalimat masukan. Huruf kapital dan non kapital dalam kalimat masukan dianggap sama, bilangan dan spasi tidak dihitung. Keluarannya haruslah diurutkan berdasarkan alphabet terbanyak. Hanya huruf yang muncul di kalimat masukan yang boleh ditampilkan dalam keluaran.\\
\end{pemrograman}
